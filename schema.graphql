# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with a globally unique `ID`."
interface Node {
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
}

type ClsBot implements Node {
    "Reads a single `ClsMessenger` that is related to this `ClsBot`."
    clsMessengerByIdMessenger: ClsMessenger
    code: String
    dateCreate: Datetime!
    idMessenger: UUID!
    isDeleted: Boolean!
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    "Reads and enables pagination through a set of `RegIncomRequest`."
    regIncomRequestsByIdBot(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegIncomRequestCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegIncomRequestFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegIncomRequest`."
        orderBy: [RegIncomRequestsOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegIncomRequestsConnection!
    "Reads and enables pagination through a set of `RegMessageRoute`."
    regMessageRoutesByIdBot(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegMessageRouteCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegMessageRouteFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegMessageRoute`."
        orderBy: [RegMessageRoutesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessageRoutesConnection!
    settings: JSON
    uuid: UUID!
}

"A connection to a list of `ClsBot` values."
type ClsBotsConnection {
    "A list of edges which contains the `ClsBot` and cursor to aid in pagination."
    edges: [ClsBotsEdge!]!
    "A list of `ClsBot` objects."
    nodes: [ClsBot]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `ClsBot` you could get from the connection."
    totalCount: Int!
}

"A `ClsBot` edge in the connection."
type ClsBotsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `ClsBot` at the end of the edge."
    node: ClsBot
}

type ClsEventType implements Node {
    "Reads a single `ClsEventType` that is related to this `ClsEventType`."
    clsEventTypeByIdParent: ClsEventType
    "Reads and enables pagination through a set of `ClsEventType`."
    clsEventTypesByIdParent(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ClsEventTypeCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ClsEventTypeFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `ClsEventType`."
        orderBy: [ClsEventTypesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsEventTypesConnection!
    "Reads a single `ClsTargetSystem` that is related to this `ClsEventType`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    code: String
    dateCreate: Datetime!
    idParent: UUID
    idTargetSystem: UUID!
    isDeleted: Boolean!
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    "Reads and enables pagination through a set of `RegIncomRequest`."
    regIncomRequestsByIdEventType(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegIncomRequestCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegIncomRequestFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegIncomRequest`."
        orderBy: [RegIncomRequestsOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegIncomRequestsConnection!
    "Reads and enables pagination through a set of `RegMessageRoute`."
    regMessageRoutesByIdEventType(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegMessageRouteCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegMessageRouteFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegMessageRoute`."
        orderBy: [RegMessageRoutesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessageRoutesConnection!
    "Reads and enables pagination through a set of `RegSentMessage`."
    regSentMessagesByIdEventType(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegSentMessageCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegSentMessageFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegSentMessage`."
        orderBy: [RegSentMessagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegSentMessagesConnection!
    type: Int!
    uuid: UUID!
}

"A connection to a list of `ClsEventType` values."
type ClsEventTypesConnection {
    "A list of edges which contains the `ClsEventType` and cursor to aid in pagination."
    edges: [ClsEventTypesEdge!]!
    "A list of `ClsEventType` objects."
    nodes: [ClsEventType]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `ClsEventType` you could get from the connection."
    totalCount: Int!
}

"A `ClsEventType` edge in the connection."
type ClsEventTypesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `ClsEventType` at the end of the edge."
    node: ClsEventType
}

type ClsMessenger implements Node {
    "Reads and enables pagination through a set of `ClsBot`."
    clsBotsByIdMessenger(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ClsBotCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ClsBotFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `ClsBot`."
        orderBy: [ClsBotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsBotsConnection!
    code: String
    dateCreate: Datetime!
    isDeleted: Boolean!
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    "Reads and enables pagination through a set of `RegIncomRequest`."
    regIncomRequestsByIdMessenger(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegIncomRequestCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegIncomRequestFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegIncomRequest`."
        orderBy: [RegIncomRequestsOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegIncomRequestsConnection!
    "Reads and enables pagination through a set of `RegMessageRoute`."
    regMessageRoutesByIdMessenger(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegMessageRouteCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegMessageRouteFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegMessageRoute`."
        orderBy: [RegMessageRoutesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessageRoutesConnection!
    "Reads and enables pagination through a set of `RegMessengerUser`."
    regMessengerUsersByIdMessenger(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegMessengerUserCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegMessengerUserFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegMessengerUser`."
        orderBy: [RegMessengerUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessengerUsersConnection!
    uuid: UUID!
}

"A connection to a list of `ClsMessenger` values."
type ClsMessengersConnection {
    "A list of edges which contains the `ClsMessenger` and cursor to aid in pagination."
    edges: [ClsMessengersEdge!]!
    "A list of `ClsMessenger` objects."
    nodes: [ClsMessenger]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `ClsMessenger` you could get from the connection."
    totalCount: Int!
}

"A `ClsMessenger` edge in the connection."
type ClsMessengersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `ClsMessenger` at the end of the edge."
    node: ClsMessenger
}

type ClsTargetSystem implements Node {
    "Reads and enables pagination through a set of `ClsEventType`."
    clsEventTypesByIdTargetSystem(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ClsEventTypeCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ClsEventTypeFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `ClsEventType`."
        orderBy: [ClsEventTypesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsEventTypesConnection!
    code: String
    dateCreate: Datetime!
    isDeleted: Boolean!
    name: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    "Reads and enables pagination through a set of `RegIncomRequest`."
    regIncomRequestsByIdTargetSystem(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegIncomRequestCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegIncomRequestFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegIncomRequest`."
        orderBy: [RegIncomRequestsOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegIncomRequestsConnection!
    "Reads and enables pagination through a set of `RegMessageRoute`."
    regMessageRoutesByIdTargetSystem(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegMessageRouteCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegMessageRouteFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegMessageRoute`."
        orderBy: [RegMessageRoutesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessageRoutesConnection!
    "Reads and enables pagination through a set of `RegSentMessage`."
    regSentMessagesByIdTargetSystem(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegSentMessageCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegSentMessageFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegSentMessage`."
        orderBy: [RegSentMessagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegSentMessagesConnection!
    "Reads and enables pagination through a set of `RegTargetSystemUser`."
    regTargetSystemUsersByIdTargetSystem(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegTargetSystemUserCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegTargetSystemUserFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegTargetSystemUser`."
        orderBy: [RegTargetSystemUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegTargetSystemUsersConnection!
    uuid: UUID!
}

"A connection to a list of `ClsTargetSystem` values."
type ClsTargetSystemsConnection {
    "A list of edges which contains the `ClsTargetSystem` and cursor to aid in pagination."
    edges: [ClsTargetSystemsEdge!]!
    "A list of `ClsTargetSystem` objects."
    nodes: [ClsTargetSystem]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `ClsTargetSystem` you could get from the connection."
    totalCount: Int!
}

"A `ClsTargetSystem` edge in the connection."
type ClsTargetSystemsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `ClsTargetSystem` at the end of the edge."
    node: ClsTargetSystem
}

type ClsUser implements Node {
    code: String
    dateCreate: Datetime!
    email: String
    firstname: String
    identificator: String
    isDeleted: Boolean!
    lastname: String
    login: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    patronymic: String
    "Reads and enables pagination through a set of `RegIncomRequest`."
    regIncomRequestsByIdUser(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegIncomRequestCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegIncomRequestFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegIncomRequest`."
        orderBy: [RegIncomRequestsOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegIncomRequestsConnection!
    "Reads and enables pagination through a set of `RegMessageRoute`."
    regMessageRoutesByIdUser(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegMessageRouteCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegMessageRouteFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegMessageRoute`."
        orderBy: [RegMessageRoutesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessageRoutesConnection!
    "Reads and enables pagination through a set of `RegMessengerUser`."
    regMessengerUsersByIdUser(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegMessengerUserCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegMessengerUserFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegMessengerUser`."
        orderBy: [RegMessengerUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessengerUsersConnection!
    "Reads and enables pagination through a set of `RegSentMessage`."
    regSentMessagesByIdUser(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegSentMessageCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegSentMessageFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegSentMessage`."
        orderBy: [RegSentMessagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegSentMessagesConnection!
    "Reads and enables pagination through a set of `RegTargetSystemUser`."
    regTargetSystemUsersByIdUser(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegTargetSystemUserCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegTargetSystemUserFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegTargetSystemUser`."
        orderBy: [RegTargetSystemUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegTargetSystemUsersConnection!
    uuid: UUID!
}

"A connection to a list of `ClsUser` values."
type ClsUsersConnection {
    "A list of edges which contains the `ClsUser` and cursor to aid in pagination."
    edges: [ClsUsersEdge!]!
    "A list of `ClsUser` objects."
    nodes: [ClsUser]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `ClsUser` you could get from the connection."
    totalCount: Int!
}

"A `ClsUser` edge in the connection."
type ClsUsersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `ClsUser` at the end of the edge."
    node: ClsUser
}

"The output of our create `ClsBot` mutation."
type CreateClsBotPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsBot` that was created by this mutation."
    clsBot: ClsBot
    "An edge for our `ClsBot`. May be used by Relay 1."
    clsBotEdge(
        "The method to use when ordering `ClsBot`."
        orderBy: [ClsBotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsBotsEdge
    "Reads a single `ClsMessenger` that is related to this `ClsBot`."
    clsMessengerByIdMessenger: ClsMessenger
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `ClsEventType` mutation."
type CreateClsEventTypePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsEventType` that was created by this mutation."
    clsEventType: ClsEventType
    "Reads a single `ClsEventType` that is related to this `ClsEventType`."
    clsEventTypeByIdParent: ClsEventType
    "An edge for our `ClsEventType`. May be used by Relay 1."
    clsEventTypeEdge(
        "The method to use when ordering `ClsEventType`."
        orderBy: [ClsEventTypesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsEventTypesEdge
    "Reads a single `ClsTargetSystem` that is related to this `ClsEventType`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `ClsMessenger` mutation."
type CreateClsMessengerPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsMessenger` that was created by this mutation."
    clsMessenger: ClsMessenger
    "An edge for our `ClsMessenger`. May be used by Relay 1."
    clsMessengerEdge(
        "The method to use when ordering `ClsMessenger`."
        orderBy: [ClsMessengersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsMessengersEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `ClsTargetSystem` mutation."
type CreateClsTargetSystemPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsTargetSystem` that was created by this mutation."
    clsTargetSystem: ClsTargetSystem
    "An edge for our `ClsTargetSystem`. May be used by Relay 1."
    clsTargetSystemEdge(
        "The method to use when ordering `ClsTargetSystem`."
        orderBy: [ClsTargetSystemsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsTargetSystemsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `ClsUser` mutation."
type CreateClsUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsUser` that was created by this mutation."
    clsUser: ClsUser
    "An edge for our `ClsUser`. May be used by Relay 1."
    clsUserEdge(
        "The method to use when ordering `ClsUser`."
        orderBy: [ClsUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsUsersEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our create `RegIncomRequest` mutation."
type CreateRegIncomRequestPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsBot` that is related to this `RegIncomRequest`."
    clsBotByIdBot: ClsBot
    "Reads a single `ClsEventType` that is related to this `RegIncomRequest`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsMessenger` that is related to this `RegIncomRequest`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsTargetSystem` that is related to this `RegIncomRequest`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegIncomRequest`."
    clsUserByIdUser: ClsUser
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegIncomRequest` that was created by this mutation."
    regIncomRequest: RegIncomRequest
    "An edge for our `RegIncomRequest`. May be used by Relay 1."
    regIncomRequestEdge(
        "The method to use when ordering `RegIncomRequest`."
        orderBy: [RegIncomRequestsOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegIncomRequestsEdge
}

"The output of our create `RegMessageRoute` mutation."
type CreateRegMessageRoutePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsBot` that is related to this `RegMessageRoute`."
    clsBotByIdBot: ClsBot
    "Reads a single `ClsEventType` that is related to this `RegMessageRoute`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsMessenger` that is related to this `RegMessageRoute`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsTargetSystem` that is related to this `RegMessageRoute`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegMessageRoute`."
    clsUserByIdUser: ClsUser
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegMessageRoute` that was created by this mutation."
    regMessageRoute: RegMessageRoute
    "An edge for our `RegMessageRoute`. May be used by Relay 1."
    regMessageRouteEdge(
        "The method to use when ordering `RegMessageRoute`."
        orderBy: [RegMessageRoutesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessageRoutesEdge
}

"The output of our create `RegMessengerUser` mutation."
type CreateRegMessengerUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsMessenger` that is related to this `RegMessengerUser`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsUser` that is related to this `RegMessengerUser`."
    clsUserByIdUser: ClsUser
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegMessengerUser` that was created by this mutation."
    regMessengerUser: RegMessengerUser
    "An edge for our `RegMessengerUser`. May be used by Relay 1."
    regMessengerUserEdge(
        "The method to use when ordering `RegMessengerUser`."
        orderBy: [RegMessengerUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessengerUsersEdge
}

"The output of our create `RegSentMessage` mutation."
type CreateRegSentMessagePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsEventType` that is related to this `RegSentMessage`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsTargetSystem` that is related to this `RegSentMessage`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegSentMessage`."
    clsUserByIdUser: ClsUser
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `RegIncomRequest` that is related to this `RegSentMessage`."
    regIncomRequestByIdIncomRequest: RegIncomRequest
    "The `RegSentMessage` that was created by this mutation."
    regSentMessage: RegSentMessage
    "An edge for our `RegSentMessage`. May be used by Relay 1."
    regSentMessageEdge(
        "The method to use when ordering `RegSentMessage`."
        orderBy: [RegSentMessagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegSentMessagesEdge
}

"The output of our create `RegTargetSystemUser` mutation."
type CreateRegTargetSystemUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsTargetSystem` that is related to this `RegTargetSystemUser`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegTargetSystemUser`."
    clsUserByIdUser: ClsUser
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegTargetSystemUser` that was created by this mutation."
    regTargetSystemUser: RegTargetSystemUser
    "An edge for our `RegTargetSystemUser`. May be used by Relay 1."
    regTargetSystemUserEdge(
        "The method to use when ordering `RegTargetSystemUser`."
        orderBy: [RegTargetSystemUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegTargetSystemUsersEdge
}

"The output of our delete `ClsBot` mutation."
type DeleteClsBotPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsBot` that was deleted by this mutation."
    clsBot: ClsBot
    "An edge for our `ClsBot`. May be used by Relay 1."
    clsBotEdge(
        "The method to use when ordering `ClsBot`."
        orderBy: [ClsBotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsBotsEdge
    "Reads a single `ClsMessenger` that is related to this `ClsBot`."
    clsMessengerByIdMessenger: ClsMessenger
    deletedClsBotId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `ClsEventType` mutation."
type DeleteClsEventTypePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsEventType` that was deleted by this mutation."
    clsEventType: ClsEventType
    "Reads a single `ClsEventType` that is related to this `ClsEventType`."
    clsEventTypeByIdParent: ClsEventType
    "An edge for our `ClsEventType`. May be used by Relay 1."
    clsEventTypeEdge(
        "The method to use when ordering `ClsEventType`."
        orderBy: [ClsEventTypesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsEventTypesEdge
    "Reads a single `ClsTargetSystem` that is related to this `ClsEventType`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    deletedClsEventTypeId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `ClsMessenger` mutation."
type DeleteClsMessengerPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsMessenger` that was deleted by this mutation."
    clsMessenger: ClsMessenger
    "An edge for our `ClsMessenger`. May be used by Relay 1."
    clsMessengerEdge(
        "The method to use when ordering `ClsMessenger`."
        orderBy: [ClsMessengersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsMessengersEdge
    deletedClsMessengerId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `ClsTargetSystem` mutation."
type DeleteClsTargetSystemPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsTargetSystem` that was deleted by this mutation."
    clsTargetSystem: ClsTargetSystem
    "An edge for our `ClsTargetSystem`. May be used by Relay 1."
    clsTargetSystemEdge(
        "The method to use when ordering `ClsTargetSystem`."
        orderBy: [ClsTargetSystemsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsTargetSystemsEdge
    deletedClsTargetSystemId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `ClsUser` mutation."
type DeleteClsUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsUser` that was deleted by this mutation."
    clsUser: ClsUser
    "An edge for our `ClsUser`. May be used by Relay 1."
    clsUserEdge(
        "The method to use when ordering `ClsUser`."
        orderBy: [ClsUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsUsersEdge
    deletedClsUserId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our `deleteNoSentMessages` mutation."
type DeleteNoSentMessagesPayload {
    bigInt: BigInt
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our `deleteNoSentRequests` mutation."
type DeleteNoSentRequestsPayload {
    bigInt: BigInt
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our `deleteReadRequests` mutation."
type DeleteReadRequestsPayload {
    bigInt: BigInt
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our delete `RegIncomRequest` mutation."
type DeleteRegIncomRequestPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsBot` that is related to this `RegIncomRequest`."
    clsBotByIdBot: ClsBot
    "Reads a single `ClsEventType` that is related to this `RegIncomRequest`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsMessenger` that is related to this `RegIncomRequest`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsTargetSystem` that is related to this `RegIncomRequest`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegIncomRequest`."
    clsUserByIdUser: ClsUser
    deletedRegIncomRequestId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegIncomRequest` that was deleted by this mutation."
    regIncomRequest: RegIncomRequest
    "An edge for our `RegIncomRequest`. May be used by Relay 1."
    regIncomRequestEdge(
        "The method to use when ordering `RegIncomRequest`."
        orderBy: [RegIncomRequestsOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegIncomRequestsEdge
}

"The output of our delete `RegMessageRoute` mutation."
type DeleteRegMessageRoutePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsBot` that is related to this `RegMessageRoute`."
    clsBotByIdBot: ClsBot
    "Reads a single `ClsEventType` that is related to this `RegMessageRoute`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsMessenger` that is related to this `RegMessageRoute`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsTargetSystem` that is related to this `RegMessageRoute`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegMessageRoute`."
    clsUserByIdUser: ClsUser
    deletedRegMessageRouteId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegMessageRoute` that was deleted by this mutation."
    regMessageRoute: RegMessageRoute
    "An edge for our `RegMessageRoute`. May be used by Relay 1."
    regMessageRouteEdge(
        "The method to use when ordering `RegMessageRoute`."
        orderBy: [RegMessageRoutesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessageRoutesEdge
}

"The output of our delete `RegMessengerUser` mutation."
type DeleteRegMessengerUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsMessenger` that is related to this `RegMessengerUser`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsUser` that is related to this `RegMessengerUser`."
    clsUserByIdUser: ClsUser
    deletedRegMessengerUserId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegMessengerUser` that was deleted by this mutation."
    regMessengerUser: RegMessengerUser
    "An edge for our `RegMessengerUser`. May be used by Relay 1."
    regMessengerUserEdge(
        "The method to use when ordering `RegMessengerUser`."
        orderBy: [RegMessengerUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessengerUsersEdge
}

"The output of our delete `RegSentMessage` mutation."
type DeleteRegSentMessagePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsEventType` that is related to this `RegSentMessage`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsTargetSystem` that is related to this `RegSentMessage`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegSentMessage`."
    clsUserByIdUser: ClsUser
    deletedRegSentMessageId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `RegIncomRequest` that is related to this `RegSentMessage`."
    regIncomRequestByIdIncomRequest: RegIncomRequest
    "The `RegSentMessage` that was deleted by this mutation."
    regSentMessage: RegSentMessage
    "An edge for our `RegSentMessage`. May be used by Relay 1."
    regSentMessageEdge(
        "The method to use when ordering `RegSentMessage`."
        orderBy: [RegSentMessagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegSentMessagesEdge
}

"The output of our delete `RegTargetSystemUser` mutation."
type DeleteRegTargetSystemUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsTargetSystem` that is related to this `RegTargetSystemUser`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegTargetSystemUser`."
    clsUserByIdUser: ClsUser
    deletedRegTargetSystemUserId: ID
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegTargetSystemUser` that was deleted by this mutation."
    regTargetSystemUser: RegTargetSystemUser
    "An edge for our `RegTargetSystemUser`. May be used by Relay 1."
    regTargetSystemUserEdge(
        "The method to use when ordering `RegTargetSystemUser`."
        orderBy: [RegTargetSystemUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegTargetSystemUsersEdge
}

"The output of our `deleteSentMessages` mutation."
type DeleteSentMessagesPayload {
    bigInt: BigInt
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our `deleteSentRequests` mutation."
type DeleteSentRequestsPayload {
    bigInt: BigInt
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The root mutation type which contains root level fields which mutate data."
type Mutation {
    "Creates a single `ClsBot`."
    createClsBot(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateClsBotInput!
    ): CreateClsBotPayload
    "Creates a single `ClsEventType`."
    createClsEventType(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateClsEventTypeInput!
    ): CreateClsEventTypePayload
    "Creates a single `ClsMessenger`."
    createClsMessenger(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateClsMessengerInput!
    ): CreateClsMessengerPayload
    "Creates a single `ClsTargetSystem`."
    createClsTargetSystem(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateClsTargetSystemInput!
    ): CreateClsTargetSystemPayload
    "Creates a single `ClsUser`."
    createClsUser(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateClsUserInput!
    ): CreateClsUserPayload
    "Creates a single `RegIncomRequest`."
    createRegIncomRequest(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateRegIncomRequestInput!
    ): CreateRegIncomRequestPayload
    "Creates a single `RegMessageRoute`."
    createRegMessageRoute(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateRegMessageRouteInput!
    ): CreateRegMessageRoutePayload
    "Creates a single `RegMessengerUser`."
    createRegMessengerUser(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateRegMessengerUserInput!
    ): CreateRegMessengerUserPayload
    "Creates a single `RegSentMessage`."
    createRegSentMessage(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateRegSentMessageInput!
    ): CreateRegSentMessagePayload
    "Creates a single `RegTargetSystemUser`."
    createRegTargetSystemUser(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: CreateRegTargetSystemUserInput!
    ): CreateRegTargetSystemUserPayload
    "Deletes a single `ClsBot` using its globally unique id."
    deleteClsBot(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteClsBotInput!
    ): DeleteClsBotPayload
    "Deletes a single `ClsBot` using a unique key."
    deleteClsBotByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteClsBotByUuidInput!
    ): DeleteClsBotPayload
    "Deletes a single `ClsEventType` using its globally unique id."
    deleteClsEventType(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteClsEventTypeInput!
    ): DeleteClsEventTypePayload
    "Deletes a single `ClsEventType` using a unique key."
    deleteClsEventTypeByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteClsEventTypeByUuidInput!
    ): DeleteClsEventTypePayload
    "Deletes a single `ClsMessenger` using its globally unique id."
    deleteClsMessenger(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteClsMessengerInput!
    ): DeleteClsMessengerPayload
    "Deletes a single `ClsMessenger` using a unique key."
    deleteClsMessengerByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteClsMessengerByUuidInput!
    ): DeleteClsMessengerPayload
    "Deletes a single `ClsTargetSystem` using its globally unique id."
    deleteClsTargetSystem(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteClsTargetSystemInput!
    ): DeleteClsTargetSystemPayload
    "Deletes a single `ClsTargetSystem` using a unique key."
    deleteClsTargetSystemByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteClsTargetSystemByUuidInput!
    ): DeleteClsTargetSystemPayload
    "Deletes a single `ClsUser` using its globally unique id."
    deleteClsUser(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteClsUserInput!
    ): DeleteClsUserPayload
    "Deletes a single `ClsUser` using a unique key."
    deleteClsUserByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteClsUserByUuidInput!
    ): DeleteClsUserPayload
    deleteNoSentMessages(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteNoSentMessagesInput!
    ): DeleteNoSentMessagesPayload
    deleteNoSentRequests(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteNoSentRequestsInput!
    ): DeleteNoSentRequestsPayload
    deleteReadRequests(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteReadRequestsInput!
    ): DeleteReadRequestsPayload
    "Deletes a single `RegIncomRequest` using its globally unique id."
    deleteRegIncomRequest(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteRegIncomRequestInput!
    ): DeleteRegIncomRequestPayload
    "Deletes a single `RegIncomRequest` using a unique key."
    deleteRegIncomRequestByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteRegIncomRequestByUuidInput!
    ): DeleteRegIncomRequestPayload
    "Deletes a single `RegMessageRoute` using its globally unique id."
    deleteRegMessageRoute(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteRegMessageRouteInput!
    ): DeleteRegMessageRoutePayload
    "Deletes a single `RegMessageRoute` using a unique key."
    deleteRegMessageRouteByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteRegMessageRouteByUuidInput!
    ): DeleteRegMessageRoutePayload
    "Deletes a single `RegMessengerUser` using its globally unique id."
    deleteRegMessengerUser(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteRegMessengerUserInput!
    ): DeleteRegMessengerUserPayload
    "Deletes a single `RegMessengerUser` using a unique key."
    deleteRegMessengerUserByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteRegMessengerUserByUuidInput!
    ): DeleteRegMessengerUserPayload
    "Deletes a single `RegSentMessage` using its globally unique id."
    deleteRegSentMessage(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteRegSentMessageInput!
    ): DeleteRegSentMessagePayload
    "Deletes a single `RegSentMessage` using a unique key."
    deleteRegSentMessageByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteRegSentMessageByUuidInput!
    ): DeleteRegSentMessagePayload
    "Deletes a single `RegTargetSystemUser` using its globally unique id."
    deleteRegTargetSystemUser(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteRegTargetSystemUserInput!
    ): DeleteRegTargetSystemUserPayload
    "Deletes a single `RegTargetSystemUser` using a unique key."
    deleteRegTargetSystemUserByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteRegTargetSystemUserByUuidInput!
    ): DeleteRegTargetSystemUserPayload
    deleteSentMessages(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteSentMessagesInput!
    ): DeleteSentMessagesPayload
    deleteSentRequests(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: DeleteSentRequestsInput!
    ): DeleteSentRequestsPayload
    "Updates a single `ClsBot` using its globally unique id and a patch."
    updateClsBot(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateClsBotInput!
    ): UpdateClsBotPayload
    "Updates a single `ClsBot` using a unique key and a patch."
    updateClsBotByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateClsBotByUuidInput!
    ): UpdateClsBotPayload
    "Updates a single `ClsEventType` using its globally unique id and a patch."
    updateClsEventType(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateClsEventTypeInput!
    ): UpdateClsEventTypePayload
    "Updates a single `ClsEventType` using a unique key and a patch."
    updateClsEventTypeByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateClsEventTypeByUuidInput!
    ): UpdateClsEventTypePayload
    "Updates a single `ClsMessenger` using its globally unique id and a patch."
    updateClsMessenger(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateClsMessengerInput!
    ): UpdateClsMessengerPayload
    "Updates a single `ClsMessenger` using a unique key and a patch."
    updateClsMessengerByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateClsMessengerByUuidInput!
    ): UpdateClsMessengerPayload
    "Updates a single `ClsTargetSystem` using its globally unique id and a patch."
    updateClsTargetSystem(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateClsTargetSystemInput!
    ): UpdateClsTargetSystemPayload
    "Updates a single `ClsTargetSystem` using a unique key and a patch."
    updateClsTargetSystemByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateClsTargetSystemByUuidInput!
    ): UpdateClsTargetSystemPayload
    "Updates a single `ClsUser` using its globally unique id and a patch."
    updateClsUser(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateClsUserInput!
    ): UpdateClsUserPayload
    "Updates a single `ClsUser` using a unique key and a patch."
    updateClsUserByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateClsUserByUuidInput!
    ): UpdateClsUserPayload
    "Updates a single `RegIncomRequest` using its globally unique id and a patch."
    updateRegIncomRequest(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateRegIncomRequestInput!
    ): UpdateRegIncomRequestPayload
    "Updates a single `RegIncomRequest` using a unique key and a patch."
    updateRegIncomRequestByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateRegIncomRequestByUuidInput!
    ): UpdateRegIncomRequestPayload
    "Updates a single `RegMessageRoute` using its globally unique id and a patch."
    updateRegMessageRoute(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateRegMessageRouteInput!
    ): UpdateRegMessageRoutePayload
    "Updates a single `RegMessageRoute` using a unique key and a patch."
    updateRegMessageRouteByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateRegMessageRouteByUuidInput!
    ): UpdateRegMessageRoutePayload
    "Updates a single `RegMessengerUser` using its globally unique id and a patch."
    updateRegMessengerUser(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateRegMessengerUserInput!
    ): UpdateRegMessengerUserPayload
    "Updates a single `RegMessengerUser` using a unique key and a patch."
    updateRegMessengerUserByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateRegMessengerUserByUuidInput!
    ): UpdateRegMessengerUserPayload
    "Updates a single `RegSentMessage` using its globally unique id and a patch."
    updateRegSentMessage(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateRegSentMessageInput!
    ): UpdateRegSentMessagePayload
    "Updates a single `RegSentMessage` using a unique key and a patch."
    updateRegSentMessageByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateRegSentMessageByUuidInput!
    ): UpdateRegSentMessagePayload
    "Updates a single `RegTargetSystemUser` using its globally unique id and a patch."
    updateRegTargetSystemUser(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateRegTargetSystemUserInput!
    ): UpdateRegTargetSystemUserPayload
    "Updates a single `RegTargetSystemUser` using a unique key and a patch."
    updateRegTargetSystemUserByUuid(
        "The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields."
        input: UpdateRegTargetSystemUserByUuidInput!
    ): UpdateRegTargetSystemUserPayload
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: Cursor
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: Cursor
}

"The root query type which gives access points into the data universe."
type Query implements Node {
    "Reads and enables pagination through a set of `ClsBot`."
    allClsBots(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ClsBotCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ClsBotFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `ClsBot`."
        orderBy: [ClsBotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsBotsConnection
    "Reads and enables pagination through a set of `ClsEventType`."
    allClsEventTypes(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ClsEventTypeCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ClsEventTypeFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `ClsEventType`."
        orderBy: [ClsEventTypesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsEventTypesConnection
    "Reads and enables pagination through a set of `ClsMessenger`."
    allClsMessengers(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ClsMessengerCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ClsMessengerFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `ClsMessenger`."
        orderBy: [ClsMessengersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsMessengersConnection
    "Reads and enables pagination through a set of `ClsTargetSystem`."
    allClsTargetSystems(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ClsTargetSystemCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ClsTargetSystemFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `ClsTargetSystem`."
        orderBy: [ClsTargetSystemsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsTargetSystemsConnection
    "Reads and enables pagination through a set of `ClsUser`."
    allClsUsers(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: ClsUserCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: ClsUserFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `ClsUser`."
        orderBy: [ClsUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsUsersConnection
    "Reads and enables pagination through a set of `RegIncomRequest`."
    allRegIncomRequests(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegIncomRequestCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegIncomRequestFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegIncomRequest`."
        orderBy: [RegIncomRequestsOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegIncomRequestsConnection
    "Reads and enables pagination through a set of `RegMessageRoute`."
    allRegMessageRoutes(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegMessageRouteCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegMessageRouteFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegMessageRoute`."
        orderBy: [RegMessageRoutesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessageRoutesConnection
    "Reads and enables pagination through a set of `RegMessengerUser`."
    allRegMessengerUsers(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegMessengerUserCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegMessengerUserFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegMessengerUser`."
        orderBy: [RegMessengerUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessengerUsersConnection
    "Reads and enables pagination through a set of `RegSentMessage`."
    allRegSentMessages(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegSentMessageCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegSentMessageFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegSentMessage`."
        orderBy: [RegSentMessagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegSentMessagesConnection
    "Reads and enables pagination through a set of `RegTargetSystemUser`."
    allRegTargetSystemUsers(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegTargetSystemUserCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegTargetSystemUserFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegTargetSystemUser`."
        orderBy: [RegTargetSystemUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegTargetSystemUsersConnection
    "Reads and enables pagination through a set of `VMessengerUserMessageRoute`."
    allVMessengerUserMessageRoutes(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: VMessengerUserMessageRouteCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: VMessengerUserMessageRouteFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `VMessengerUserMessageRoute`."
        orderBy: [VMessengerUserMessageRoutesOrderBy!] = [NATURAL]
    ): VMessengerUserMessageRoutesConnection
    "Reads a single `ClsBot` using its globally unique `ID`."
    clsBot(
        "The globally unique `ID` to be used in selecting a single `ClsBot`."
        nodeId: ID!
    ): ClsBot
    clsBotByUuid(uuid: UUID!): ClsBot
    "Reads a single `ClsEventType` using its globally unique `ID`."
    clsEventType(
        "The globally unique `ID` to be used in selecting a single `ClsEventType`."
        nodeId: ID!
    ): ClsEventType
    clsEventTypeByUuid(uuid: UUID!): ClsEventType
    "Reads a single `ClsMessenger` using its globally unique `ID`."
    clsMessenger(
        "The globally unique `ID` to be used in selecting a single `ClsMessenger`."
        nodeId: ID!
    ): ClsMessenger
    clsMessengerByUuid(uuid: UUID!): ClsMessenger
    "Reads a single `ClsTargetSystem` using its globally unique `ID`."
    clsTargetSystem(
        "The globally unique `ID` to be used in selecting a single `ClsTargetSystem`."
        nodeId: ID!
    ): ClsTargetSystem
    clsTargetSystemByUuid(uuid: UUID!): ClsTargetSystem
    "Reads a single `ClsUser` using its globally unique `ID`."
    clsUser(
        "The globally unique `ID` to be used in selecting a single `ClsUser`."
        nodeId: ID!
    ): ClsUser
    clsUserByUuid(uuid: UUID!): ClsUser
    "Fetches an object given its globally unique `ID`."
    node(
        "The globally unique `ID`."
        nodeId: ID!
    ): Node
    "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`."
    nodeId: ID!
    "Exposes the root query type nested one level down. This is helpful for Relay 1 which can only query top level fields if they are in a particular form."
    query: Query!
    "Reads a single `RegIncomRequest` using its globally unique `ID`."
    regIncomRequest(
        "The globally unique `ID` to be used in selecting a single `RegIncomRequest`."
        nodeId: ID!
    ): RegIncomRequest
    regIncomRequestByUuid(uuid: UUID!): RegIncomRequest
    "Reads a single `RegMessageRoute` using its globally unique `ID`."
    regMessageRoute(
        "The globally unique `ID` to be used in selecting a single `RegMessageRoute`."
        nodeId: ID!
    ): RegMessageRoute
    regMessageRouteByUuid(uuid: UUID!): RegMessageRoute
    "Reads a single `RegMessengerUser` using its globally unique `ID`."
    regMessengerUser(
        "The globally unique `ID` to be used in selecting a single `RegMessengerUser`."
        nodeId: ID!
    ): RegMessengerUser
    regMessengerUserByUuid(uuid: UUID!): RegMessengerUser
    "Reads a single `RegSentMessage` using its globally unique `ID`."
    regSentMessage(
        "The globally unique `ID` to be used in selecting a single `RegSentMessage`."
        nodeId: ID!
    ): RegSentMessage
    regSentMessageByUuid(uuid: UUID!): RegSentMessage
    "Reads a single `RegTargetSystemUser` using its globally unique `ID`."
    regTargetSystemUser(
        "The globally unique `ID` to be used in selecting a single `RegTargetSystemUser`."
        nodeId: ID!
    ): RegTargetSystemUser
    regTargetSystemUserByUuid(uuid: UUID!): RegTargetSystemUser
}

type RegIncomRequest implements Node {
    "Reads a single `ClsBot` that is related to this `RegIncomRequest`."
    clsBotByIdBot: ClsBot
    "Reads a single `ClsEventType` that is related to this `RegIncomRequest`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsMessenger` that is related to this `RegIncomRequest`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsTargetSystem` that is related to this `RegIncomRequest`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegIncomRequest`."
    clsUserByIdUser: ClsUser
    dateCreate: Datetime!
    idBot: UUID!
    idEventType: UUID!
    idMessenger: UUID!
    idTargetSystem: UUID!
    idUser: UUID
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    "Reads and enables pagination through a set of `RegSentMessage`."
    regSentMessagesByIdIncomRequest(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: RegSentMessageCondition,
        "A filter to be used in determining which values should be returned by the collection."
        filter: RegSentMessageFilter,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `RegSentMessage`."
        orderBy: [RegSentMessagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegSentMessagesConnection!
    status: Int
    uuid: UUID!
}

"A connection to a list of `RegIncomRequest` values."
type RegIncomRequestsConnection {
    "A list of edges which contains the `RegIncomRequest` and cursor to aid in pagination."
    edges: [RegIncomRequestsEdge!]!
    "A list of `RegIncomRequest` objects."
    nodes: [RegIncomRequest]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `RegIncomRequest` you could get from the connection."
    totalCount: Int!
}

"A `RegIncomRequest` edge in the connection."
type RegIncomRequestsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `RegIncomRequest` at the end of the edge."
    node: RegIncomRequest
}

type RegMessageRoute implements Node {
    "Reads a single `ClsBot` that is related to this `RegMessageRoute`."
    clsBotByIdBot: ClsBot
    "Reads a single `ClsEventType` that is related to this `RegMessageRoute`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsMessenger` that is related to this `RegMessageRoute`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsTargetSystem` that is related to this `RegMessageRoute`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegMessageRoute`."
    clsUserByIdUser: ClsUser
    dateActivation: Datetime
    dateCreate: Datetime!
    idBot: UUID!
    idEventType: UUID!
    idMessenger: UUID!
    idTargetSystem: UUID!
    idUser: UUID
    isDeleted: Boolean!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    uuid: UUID!
}

"A connection to a list of `RegMessageRoute` values."
type RegMessageRoutesConnection {
    "A list of edges which contains the `RegMessageRoute` and cursor to aid in pagination."
    edges: [RegMessageRoutesEdge!]!
    "A list of `RegMessageRoute` objects."
    nodes: [RegMessageRoute]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `RegMessageRoute` you could get from the connection."
    totalCount: Int!
}

"A `RegMessageRoute` edge in the connection."
type RegMessageRoutesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `RegMessageRoute` at the end of the edge."
    node: RegMessageRoute
}

type RegMessengerUser implements Node {
    "Reads a single `ClsMessenger` that is related to this `RegMessengerUser`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsUser` that is related to this `RegMessengerUser`."
    clsUserByIdUser: ClsUser
    dateCreate: Datetime!
    idMessenger: UUID!
    idUser: UUID
    isDeleted: Boolean!
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    outerId: String
    settings: JSON
    uuid: UUID!
}

"A connection to a list of `RegMessengerUser` values."
type RegMessengerUsersConnection {
    "A list of edges which contains the `RegMessengerUser` and cursor to aid in pagination."
    edges: [RegMessengerUsersEdge!]!
    "A list of `RegMessengerUser` objects."
    nodes: [RegMessengerUser]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `RegMessengerUser` you could get from the connection."
    totalCount: Int!
}

"A `RegMessengerUser` edge in the connection."
type RegMessengerUsersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `RegMessengerUser` at the end of the edge."
    node: RegMessengerUser
}

type RegSentMessage implements Node {
    attachedFile: String
    attachedFileHash: String
    attachedFileSize: Int
    attachedFileType: String
    "Reads a single `ClsEventType` that is related to this `RegSentMessage`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsTargetSystem` that is related to this `RegSentMessage`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegSentMessage`."
    clsUserByIdUser: ClsUser
    dateCreate: Datetime!
    idEventType: UUID!
    idIncomRequest: UUID
    idTargetSystem: UUID!
    idUser: UUID
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    "Reads a single `RegIncomRequest` that is related to this `RegSentMessage`."
    regIncomRequestByIdIncomRequest: RegIncomRequest
    settings: JSON
    status: Int
    text: String
    uuid: UUID!
}

"A connection to a list of `RegSentMessage` values."
type RegSentMessagesConnection {
    "A list of edges which contains the `RegSentMessage` and cursor to aid in pagination."
    edges: [RegSentMessagesEdge!]!
    "A list of `RegSentMessage` objects."
    nodes: [RegSentMessage]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `RegSentMessage` you could get from the connection."
    totalCount: Int!
}

"A `RegSentMessage` edge in the connection."
type RegSentMessagesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `RegSentMessage` at the end of the edge."
    node: RegSentMessage
}

type RegTargetSystemUser implements Node {
    "Reads a single `ClsTargetSystem` that is related to this `RegTargetSystemUser`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegTargetSystemUser`."
    clsUserByIdUser: ClsUser
    dateCreate: Datetime!
    email: String
    firstname: String
    idTargetSystem: UUID!
    idUser: UUID
    isDeleted: Boolean!
    lastname: String
    login: String
    "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
    nodeId: ID!
    outerId: String
    patronymic: String
    uuid: UUID!
}

"A connection to a list of `RegTargetSystemUser` values."
type RegTargetSystemUsersConnection {
    "A list of edges which contains the `RegTargetSystemUser` and cursor to aid in pagination."
    edges: [RegTargetSystemUsersEdge!]!
    "A list of `RegTargetSystemUser` objects."
    nodes: [RegTargetSystemUser]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `RegTargetSystemUser` you could get from the connection."
    totalCount: Int!
}

"A `RegTargetSystemUser` edge in the connection."
type RegTargetSystemUsersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `RegTargetSystemUser` at the end of the edge."
    node: RegTargetSystemUser
}

"The output of our update `ClsBot` mutation."
type UpdateClsBotPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsBot` that was updated by this mutation."
    clsBot: ClsBot
    "An edge for our `ClsBot`. May be used by Relay 1."
    clsBotEdge(
        "The method to use when ordering `ClsBot`."
        orderBy: [ClsBotsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsBotsEdge
    "Reads a single `ClsMessenger` that is related to this `ClsBot`."
    clsMessengerByIdMessenger: ClsMessenger
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `ClsEventType` mutation."
type UpdateClsEventTypePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsEventType` that was updated by this mutation."
    clsEventType: ClsEventType
    "Reads a single `ClsEventType` that is related to this `ClsEventType`."
    clsEventTypeByIdParent: ClsEventType
    "An edge for our `ClsEventType`. May be used by Relay 1."
    clsEventTypeEdge(
        "The method to use when ordering `ClsEventType`."
        orderBy: [ClsEventTypesOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsEventTypesEdge
    "Reads a single `ClsTargetSystem` that is related to this `ClsEventType`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `ClsMessenger` mutation."
type UpdateClsMessengerPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsMessenger` that was updated by this mutation."
    clsMessenger: ClsMessenger
    "An edge for our `ClsMessenger`. May be used by Relay 1."
    clsMessengerEdge(
        "The method to use when ordering `ClsMessenger`."
        orderBy: [ClsMessengersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsMessengersEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `ClsTargetSystem` mutation."
type UpdateClsTargetSystemPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsTargetSystem` that was updated by this mutation."
    clsTargetSystem: ClsTargetSystem
    "An edge for our `ClsTargetSystem`. May be used by Relay 1."
    clsTargetSystemEdge(
        "The method to use when ordering `ClsTargetSystem`."
        orderBy: [ClsTargetSystemsOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsTargetSystemsEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `ClsUser` mutation."
type UpdateClsUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "The `ClsUser` that was updated by this mutation."
    clsUser: ClsUser
    "An edge for our `ClsUser`. May be used by Relay 1."
    clsUserEdge(
        "The method to use when ordering `ClsUser`."
        orderBy: [ClsUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): ClsUsersEdge
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
}

"The output of our update `RegIncomRequest` mutation."
type UpdateRegIncomRequestPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsBot` that is related to this `RegIncomRequest`."
    clsBotByIdBot: ClsBot
    "Reads a single `ClsEventType` that is related to this `RegIncomRequest`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsMessenger` that is related to this `RegIncomRequest`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsTargetSystem` that is related to this `RegIncomRequest`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegIncomRequest`."
    clsUserByIdUser: ClsUser
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegIncomRequest` that was updated by this mutation."
    regIncomRequest: RegIncomRequest
    "An edge for our `RegIncomRequest`. May be used by Relay 1."
    regIncomRequestEdge(
        "The method to use when ordering `RegIncomRequest`."
        orderBy: [RegIncomRequestsOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegIncomRequestsEdge
}

"The output of our update `RegMessageRoute` mutation."
type UpdateRegMessageRoutePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsBot` that is related to this `RegMessageRoute`."
    clsBotByIdBot: ClsBot
    "Reads a single `ClsEventType` that is related to this `RegMessageRoute`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsMessenger` that is related to this `RegMessageRoute`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsTargetSystem` that is related to this `RegMessageRoute`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegMessageRoute`."
    clsUserByIdUser: ClsUser
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegMessageRoute` that was updated by this mutation."
    regMessageRoute: RegMessageRoute
    "An edge for our `RegMessageRoute`. May be used by Relay 1."
    regMessageRouteEdge(
        "The method to use when ordering `RegMessageRoute`."
        orderBy: [RegMessageRoutesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessageRoutesEdge
}

"The output of our update `RegMessengerUser` mutation."
type UpdateRegMessengerUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsMessenger` that is related to this `RegMessengerUser`."
    clsMessengerByIdMessenger: ClsMessenger
    "Reads a single `ClsUser` that is related to this `RegMessengerUser`."
    clsUserByIdUser: ClsUser
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegMessengerUser` that was updated by this mutation."
    regMessengerUser: RegMessengerUser
    "An edge for our `RegMessengerUser`. May be used by Relay 1."
    regMessengerUserEdge(
        "The method to use when ordering `RegMessengerUser`."
        orderBy: [RegMessengerUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegMessengerUsersEdge
}

"The output of our update `RegSentMessage` mutation."
type UpdateRegSentMessagePayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsEventType` that is related to this `RegSentMessage`."
    clsEventTypeByIdEventType: ClsEventType
    "Reads a single `ClsTargetSystem` that is related to this `RegSentMessage`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegSentMessage`."
    clsUserByIdUser: ClsUser
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "Reads a single `RegIncomRequest` that is related to this `RegSentMessage`."
    regIncomRequestByIdIncomRequest: RegIncomRequest
    "The `RegSentMessage` that was updated by this mutation."
    regSentMessage: RegSentMessage
    "An edge for our `RegSentMessage`. May be used by Relay 1."
    regSentMessageEdge(
        "The method to use when ordering `RegSentMessage`."
        orderBy: [RegSentMessagesOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegSentMessagesEdge
}

"The output of our update `RegTargetSystemUser` mutation."
type UpdateRegTargetSystemUserPayload {
    "The exact same `clientMutationId` that was provided in the mutation input, unchanged and unused. May be used by a client to track mutations."
    clientMutationId: String
    "Reads a single `ClsTargetSystem` that is related to this `RegTargetSystemUser`."
    clsTargetSystemByIdTargetSystem: ClsTargetSystem
    "Reads a single `ClsUser` that is related to this `RegTargetSystemUser`."
    clsUserByIdUser: ClsUser
    "Our root query field type. Allows us to run any query from our mutation payload."
    query: Query
    "The `RegTargetSystemUser` that was updated by this mutation."
    regTargetSystemUser: RegTargetSystemUser
    "An edge for our `RegTargetSystemUser`. May be used by Relay 1."
    regTargetSystemUserEdge(
        "The method to use when ordering `RegTargetSystemUser`."
        orderBy: [RegTargetSystemUsersOrderBy!] = [PRIMARY_KEY_ASC]
    ): RegTargetSystemUsersEdge
}

type VMessengerUserMessageRoute {
    botName: String
    botSettings: JSON
    idBot: UUID
    idEventType: UUID
    idMessenger: UUID
    idParentEventType: UUID
    idTargetSystem: UUID
    idUser: UUID
    messengerCode: String
    outerId: String
    typeEvent: Int
    userSettings: JSON
}

"A connection to a list of `VMessengerUserMessageRoute` values."
type VMessengerUserMessageRoutesConnection {
    "A list of edges which contains the `VMessengerUserMessageRoute` and cursor to aid in pagination."
    edges: [VMessengerUserMessageRoutesEdge!]!
    "A list of `VMessengerUserMessageRoute` objects."
    nodes: [VMessengerUserMessageRoute]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `VMessengerUserMessageRoute` you could get from the connection."
    totalCount: Int!
}

"A `VMessengerUserMessageRoute` edge in the connection."
type VMessengerUserMessageRoutesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `VMessengerUserMessageRoute` at the end of the edge."
    node: VMessengerUserMessageRoute
}

"Methods to use when ordering `ClsBot`."
enum ClsBotsOrderBy {
    CODE_ASC
    CODE_DESC
    DATE_CREATE_ASC
    DATE_CREATE_DESC
    ID_MESSENGER_ASC
    ID_MESSENGER_DESC
    IS_DELETED_ASC
    IS_DELETED_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SETTINGS_ASC
    SETTINGS_DESC
    UUID_ASC
    UUID_DESC
}

"Methods to use when ordering `ClsEventType`."
enum ClsEventTypesOrderBy {
    CODE_ASC
    CODE_DESC
    DATE_CREATE_ASC
    DATE_CREATE_DESC
    ID_PARENT_ASC
    ID_PARENT_DESC
    ID_TARGET_SYSTEM_ASC
    ID_TARGET_SYSTEM_DESC
    IS_DELETED_ASC
    IS_DELETED_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    TYPE_ASC
    TYPE_DESC
    UUID_ASC
    UUID_DESC
}

"Methods to use when ordering `ClsMessenger`."
enum ClsMessengersOrderBy {
    CODE_ASC
    CODE_DESC
    DATE_CREATE_ASC
    DATE_CREATE_DESC
    IS_DELETED_ASC
    IS_DELETED_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    UUID_ASC
    UUID_DESC
}

"Methods to use when ordering `ClsTargetSystem`."
enum ClsTargetSystemsOrderBy {
    CODE_ASC
    CODE_DESC
    DATE_CREATE_ASC
    DATE_CREATE_DESC
    IS_DELETED_ASC
    IS_DELETED_DESC
    NAME_ASC
    NAME_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    UUID_ASC
    UUID_DESC
}

"Methods to use when ordering `ClsUser`."
enum ClsUsersOrderBy {
    CODE_ASC
    CODE_DESC
    DATE_CREATE_ASC
    DATE_CREATE_DESC
    EMAIL_ASC
    EMAIL_DESC
    FIRSTNAME_ASC
    FIRSTNAME_DESC
    IDENTIFICATOR_ASC
    IDENTIFICATOR_DESC
    IS_DELETED_ASC
    IS_DELETED_DESC
    LASTNAME_ASC
    LASTNAME_DESC
    LOGIN_ASC
    LOGIN_DESC
    NATURAL
    PATRONYMIC_ASC
    PATRONYMIC_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    UUID_ASC
    UUID_DESC
}

"Methods to use when ordering `RegIncomRequest`."
enum RegIncomRequestsOrderBy {
    DATE_CREATE_ASC
    DATE_CREATE_DESC
    ID_BOT_ASC
    ID_BOT_DESC
    ID_EVENT_TYPE_ASC
    ID_EVENT_TYPE_DESC
    ID_MESSENGER_ASC
    ID_MESSENGER_DESC
    ID_TARGET_SYSTEM_ASC
    ID_TARGET_SYSTEM_DESC
    ID_USER_ASC
    ID_USER_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    STATUS_ASC
    STATUS_DESC
    UUID_ASC
    UUID_DESC
}

"Methods to use when ordering `RegMessageRoute`."
enum RegMessageRoutesOrderBy {
    DATE_ACTIVATION_ASC
    DATE_ACTIVATION_DESC
    DATE_CREATE_ASC
    DATE_CREATE_DESC
    ID_BOT_ASC
    ID_BOT_DESC
    ID_EVENT_TYPE_ASC
    ID_EVENT_TYPE_DESC
    ID_MESSENGER_ASC
    ID_MESSENGER_DESC
    ID_TARGET_SYSTEM_ASC
    ID_TARGET_SYSTEM_DESC
    ID_USER_ASC
    ID_USER_DESC
    IS_DELETED_ASC
    IS_DELETED_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    UUID_ASC
    UUID_DESC
}

"Methods to use when ordering `RegMessengerUser`."
enum RegMessengerUsersOrderBy {
    DATE_CREATE_ASC
    DATE_CREATE_DESC
    ID_MESSENGER_ASC
    ID_MESSENGER_DESC
    ID_USER_ASC
    ID_USER_DESC
    IS_DELETED_ASC
    IS_DELETED_DESC
    NATURAL
    OUTER_ID_ASC
    OUTER_ID_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SETTINGS_ASC
    SETTINGS_DESC
    UUID_ASC
    UUID_DESC
}

"Methods to use when ordering `RegSentMessage`."
enum RegSentMessagesOrderBy {
    ATTACHED_FILE_ASC
    ATTACHED_FILE_DESC
    ATTACHED_FILE_HASH_ASC
    ATTACHED_FILE_HASH_DESC
    ATTACHED_FILE_SIZE_ASC
    ATTACHED_FILE_SIZE_DESC
    ATTACHED_FILE_TYPE_ASC
    ATTACHED_FILE_TYPE_DESC
    DATE_CREATE_ASC
    DATE_CREATE_DESC
    ID_EVENT_TYPE_ASC
    ID_EVENT_TYPE_DESC
    ID_INCOM_REQUEST_ASC
    ID_INCOM_REQUEST_DESC
    ID_TARGET_SYSTEM_ASC
    ID_TARGET_SYSTEM_DESC
    ID_USER_ASC
    ID_USER_DESC
    NATURAL
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    SETTINGS_ASC
    SETTINGS_DESC
    STATUS_ASC
    STATUS_DESC
    TEXT_ASC
    TEXT_DESC
    UUID_ASC
    UUID_DESC
}

"Methods to use when ordering `RegTargetSystemUser`."
enum RegTargetSystemUsersOrderBy {
    DATE_CREATE_ASC
    DATE_CREATE_DESC
    EMAIL_ASC
    EMAIL_DESC
    FIRSTNAME_ASC
    FIRSTNAME_DESC
    ID_TARGET_SYSTEM_ASC
    ID_TARGET_SYSTEM_DESC
    ID_USER_ASC
    ID_USER_DESC
    IS_DELETED_ASC
    IS_DELETED_DESC
    LASTNAME_ASC
    LASTNAME_DESC
    LOGIN_ASC
    LOGIN_DESC
    NATURAL
    OUTER_ID_ASC
    OUTER_ID_DESC
    PATRONYMIC_ASC
    PATRONYMIC_DESC
    PRIMARY_KEY_ASC
    PRIMARY_KEY_DESC
    UUID_ASC
    UUID_DESC
}

"Methods to use when ordering `VMessengerUserMessageRoute`."
enum VMessengerUserMessageRoutesOrderBy {
    BOT_NAME_ASC
    BOT_NAME_DESC
    BOT_SETTINGS_ASC
    BOT_SETTINGS_DESC
    ID_BOT_ASC
    ID_BOT_DESC
    ID_EVENT_TYPE_ASC
    ID_EVENT_TYPE_DESC
    ID_MESSENGER_ASC
    ID_MESSENGER_DESC
    ID_PARENT_EVENT_TYPE_ASC
    ID_PARENT_EVENT_TYPE_DESC
    ID_TARGET_SYSTEM_ASC
    ID_TARGET_SYSTEM_DESC
    ID_USER_ASC
    ID_USER_DESC
    MESSENGER_CODE_ASC
    MESSENGER_CODE_DESC
    NATURAL
    OUTER_ID_ASC
    OUTER_ID_DESC
    TYPE_EVENT_ASC
    TYPE_EVENT_DESC
    USER_SETTINGS_ASC
    USER_SETTINGS_DESC
}

"A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’"
input BooleanFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: Boolean
    "Equal to the specified value."
    equalTo: Boolean
    "Greater than the specified value."
    greaterThan: Boolean
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: Boolean
    "Included in the specified list."
    in: [Boolean!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: Boolean
    "Less than or equal to the specified value."
    lessThanOrEqualTo: Boolean
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: Boolean
    "Not equal to the specified value."
    notEqualTo: Boolean
    "Not included in the specified list."
    notIn: [Boolean!]
}

"A condition to be used against `ClsBot` object types. All fields are tested for equality and combined with a logical ‘and.’"
input ClsBotCondition {
    "Checks for equality with the object’s `code` field."
    code: String
    "Checks for equality with the object’s `dateCreate` field."
    dateCreate: Datetime
    "Checks for equality with the object’s `idMessenger` field."
    idMessenger: UUID
    "Checks for equality with the object’s `isDeleted` field."
    isDeleted: Boolean
    "Checks for equality with the object’s `name` field."
    name: String
    "Checks for equality with the object’s `settings` field."
    settings: JSON
    "Checks for equality with the object’s `uuid` field."
    uuid: UUID
}

"A filter to be used against `ClsBot` object types. All fields are combined with a logical ‘and.’"
input ClsBotFilter {
    "Checks for all expressions in this list."
    and: [ClsBotFilter!]
    "Filter by the object’s `code` field."
    code: StringFilter
    "Filter by the object’s `dateCreate` field."
    dateCreate: DatetimeFilter
    "Filter by the object’s `idMessenger` field."
    idMessenger: UUIDFilter
    "Filter by the object’s `isDeleted` field."
    isDeleted: BooleanFilter
    "Filter by the object’s `name` field."
    name: StringFilter
    "Negates the expression."
    not: ClsBotFilter
    "Checks for any expressions in this list."
    or: [ClsBotFilter!]
    "Filter by the object’s `settings` field."
    settings: JSONFilter
    "Filter by the object’s `uuid` field."
    uuid: UUIDFilter
}

"An input for mutations affecting `ClsBot`"
input ClsBotInput {
    code: String
    dateCreate: Datetime
    idMessenger: UUID!
    isDeleted: Boolean
    name: String
    settings: JSON
    uuid: UUID
}

"Represents an update to a `ClsBot`. Fields that are set will be updated."
input ClsBotPatch {
    code: String
    dateCreate: Datetime
    idMessenger: UUID
    isDeleted: Boolean
    name: String
    settings: JSON
    uuid: UUID
}

"A condition to be used against `ClsEventType` object types. All fields are tested for equality and combined with a logical ‘and.’"
input ClsEventTypeCondition {
    "Checks for equality with the object’s `code` field."
    code: String
    "Checks for equality with the object’s `dateCreate` field."
    dateCreate: Datetime
    "Checks for equality with the object’s `idParent` field."
    idParent: UUID
    "Checks for equality with the object’s `idTargetSystem` field."
    idTargetSystem: UUID
    "Checks for equality with the object’s `isDeleted` field."
    isDeleted: Boolean
    "Checks for equality with the object’s `name` field."
    name: String
    "Checks for equality with the object’s `type` field."
    type: Int
    "Checks for equality with the object’s `uuid` field."
    uuid: UUID
}

"A filter to be used against `ClsEventType` object types. All fields are combined with a logical ‘and.’"
input ClsEventTypeFilter {
    "Checks for all expressions in this list."
    and: [ClsEventTypeFilter!]
    "Filter by the object’s `code` field."
    code: StringFilter
    "Filter by the object’s `dateCreate` field."
    dateCreate: DatetimeFilter
    "Filter by the object’s `idParent` field."
    idParent: UUIDFilter
    "Filter by the object’s `idTargetSystem` field."
    idTargetSystem: UUIDFilter
    "Filter by the object’s `isDeleted` field."
    isDeleted: BooleanFilter
    "Filter by the object’s `name` field."
    name: StringFilter
    "Negates the expression."
    not: ClsEventTypeFilter
    "Checks for any expressions in this list."
    or: [ClsEventTypeFilter!]
    "Filter by the object’s `type` field."
    type: IntFilter
    "Filter by the object’s `uuid` field."
    uuid: UUIDFilter
}

"An input for mutations affecting `ClsEventType`"
input ClsEventTypeInput {
    code: String
    dateCreate: Datetime
    idParent: UUID
    idTargetSystem: UUID!
    isDeleted: Boolean
    name: String
    type: Int
    uuid: UUID
}

"Represents an update to a `ClsEventType`. Fields that are set will be updated."
input ClsEventTypePatch {
    code: String
    dateCreate: Datetime
    idParent: UUID
    idTargetSystem: UUID
    isDeleted: Boolean
    name: String
    type: Int
    uuid: UUID
}

"A condition to be used against `ClsMessenger` object types. All fields are tested for equality and combined with a logical ‘and.’"
input ClsMessengerCondition {
    "Checks for equality with the object’s `code` field."
    code: String
    "Checks for equality with the object’s `dateCreate` field."
    dateCreate: Datetime
    "Checks for equality with the object’s `isDeleted` field."
    isDeleted: Boolean
    "Checks for equality with the object’s `name` field."
    name: String
    "Checks for equality with the object’s `uuid` field."
    uuid: UUID
}

"A filter to be used against `ClsMessenger` object types. All fields are combined with a logical ‘and.’"
input ClsMessengerFilter {
    "Checks for all expressions in this list."
    and: [ClsMessengerFilter!]
    "Filter by the object’s `code` field."
    code: StringFilter
    "Filter by the object’s `dateCreate` field."
    dateCreate: DatetimeFilter
    "Filter by the object’s `isDeleted` field."
    isDeleted: BooleanFilter
    "Filter by the object’s `name` field."
    name: StringFilter
    "Negates the expression."
    not: ClsMessengerFilter
    "Checks for any expressions in this list."
    or: [ClsMessengerFilter!]
    "Filter by the object’s `uuid` field."
    uuid: UUIDFilter
}

"An input for mutations affecting `ClsMessenger`"
input ClsMessengerInput {
    code: String
    dateCreate: Datetime
    isDeleted: Boolean
    name: String
    uuid: UUID
}

"Represents an update to a `ClsMessenger`. Fields that are set will be updated."
input ClsMessengerPatch {
    code: String
    dateCreate: Datetime
    isDeleted: Boolean
    name: String
    uuid: UUID
}

"A condition to be used against `ClsTargetSystem` object types. All fields are tested for equality and combined with a logical ‘and.’"
input ClsTargetSystemCondition {
    "Checks for equality with the object’s `code` field."
    code: String
    "Checks for equality with the object’s `dateCreate` field."
    dateCreate: Datetime
    "Checks for equality with the object’s `isDeleted` field."
    isDeleted: Boolean
    "Checks for equality with the object’s `name` field."
    name: String
    "Checks for equality with the object’s `uuid` field."
    uuid: UUID
}

"A filter to be used against `ClsTargetSystem` object types. All fields are combined with a logical ‘and.’"
input ClsTargetSystemFilter {
    "Checks for all expressions in this list."
    and: [ClsTargetSystemFilter!]
    "Filter by the object’s `code` field."
    code: StringFilter
    "Filter by the object’s `dateCreate` field."
    dateCreate: DatetimeFilter
    "Filter by the object’s `isDeleted` field."
    isDeleted: BooleanFilter
    "Filter by the object’s `name` field."
    name: StringFilter
    "Negates the expression."
    not: ClsTargetSystemFilter
    "Checks for any expressions in this list."
    or: [ClsTargetSystemFilter!]
    "Filter by the object’s `uuid` field."
    uuid: UUIDFilter
}

"An input for mutations affecting `ClsTargetSystem`"
input ClsTargetSystemInput {
    code: String
    dateCreate: Datetime
    isDeleted: Boolean
    name: String
    uuid: UUID
}

"Represents an update to a `ClsTargetSystem`. Fields that are set will be updated."
input ClsTargetSystemPatch {
    code: String
    dateCreate: Datetime
    isDeleted: Boolean
    name: String
    uuid: UUID
}

"A condition to be used against `ClsUser` object types. All fields are tested for equality and combined with a logical ‘and.’"
input ClsUserCondition {
    "Checks for equality with the object’s `code` field."
    code: String
    "Checks for equality with the object’s `dateCreate` field."
    dateCreate: Datetime
    "Checks for equality with the object’s `email` field."
    email: String
    "Checks for equality with the object’s `firstname` field."
    firstname: String
    "Checks for equality with the object’s `identificator` field."
    identificator: String
    "Checks for equality with the object’s `isDeleted` field."
    isDeleted: Boolean
    "Checks for equality with the object’s `lastname` field."
    lastname: String
    "Checks for equality with the object’s `login` field."
    login: String
    "Checks for equality with the object’s `patronymic` field."
    patronymic: String
    "Checks for equality with the object’s `uuid` field."
    uuid: UUID
}

"A filter to be used against `ClsUser` object types. All fields are combined with a logical ‘and.’"
input ClsUserFilter {
    "Checks for all expressions in this list."
    and: [ClsUserFilter!]
    "Filter by the object’s `code` field."
    code: StringFilter
    "Filter by the object’s `dateCreate` field."
    dateCreate: DatetimeFilter
    "Filter by the object’s `email` field."
    email: StringFilter
    "Filter by the object’s `firstname` field."
    firstname: StringFilter
    "Filter by the object’s `identificator` field."
    identificator: StringFilter
    "Filter by the object’s `isDeleted` field."
    isDeleted: BooleanFilter
    "Filter by the object’s `lastname` field."
    lastname: StringFilter
    "Filter by the object’s `login` field."
    login: StringFilter
    "Negates the expression."
    not: ClsUserFilter
    "Checks for any expressions in this list."
    or: [ClsUserFilter!]
    "Filter by the object’s `patronymic` field."
    patronymic: StringFilter
    "Filter by the object’s `uuid` field."
    uuid: UUIDFilter
}

"An input for mutations affecting `ClsUser`"
input ClsUserInput {
    code: String
    dateCreate: Datetime
    email: String
    firstname: String
    identificator: String
    isDeleted: Boolean
    lastname: String
    login: String
    patronymic: String
    uuid: UUID
}

"Represents an update to a `ClsUser`. Fields that are set will be updated."
input ClsUserPatch {
    code: String
    dateCreate: Datetime
    email: String
    firstname: String
    identificator: String
    isDeleted: Boolean
    lastname: String
    login: String
    patronymic: String
    uuid: UUID
}

"All input for the create `ClsBot` mutation."
input CreateClsBotInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `ClsBot` to be created by this mutation."
    clsBot: ClsBotInput!
}

"All input for the create `ClsEventType` mutation."
input CreateClsEventTypeInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `ClsEventType` to be created by this mutation."
    clsEventType: ClsEventTypeInput!
}

"All input for the create `ClsMessenger` mutation."
input CreateClsMessengerInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `ClsMessenger` to be created by this mutation."
    clsMessenger: ClsMessengerInput!
}

"All input for the create `ClsTargetSystem` mutation."
input CreateClsTargetSystemInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `ClsTargetSystem` to be created by this mutation."
    clsTargetSystem: ClsTargetSystemInput!
}

"All input for the create `ClsUser` mutation."
input CreateClsUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `ClsUser` to be created by this mutation."
    clsUser: ClsUserInput!
}

"All input for the create `RegIncomRequest` mutation."
input CreateRegIncomRequestInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `RegIncomRequest` to be created by this mutation."
    regIncomRequest: RegIncomRequestInput!
}

"All input for the create `RegMessageRoute` mutation."
input CreateRegMessageRouteInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `RegMessageRoute` to be created by this mutation."
    regMessageRoute: RegMessageRouteInput!
}

"All input for the create `RegMessengerUser` mutation."
input CreateRegMessengerUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `RegMessengerUser` to be created by this mutation."
    regMessengerUser: RegMessengerUserInput!
}

"All input for the create `RegSentMessage` mutation."
input CreateRegSentMessageInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `RegSentMessage` to be created by this mutation."
    regSentMessage: RegSentMessageInput!
}

"All input for the create `RegTargetSystemUser` mutation."
input CreateRegTargetSystemUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The `RegTargetSystemUser` to be created by this mutation."
    regTargetSystemUser: RegTargetSystemUserInput!
}

"A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’"
input DatetimeFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: Datetime
    "Equal to the specified value."
    equalTo: Datetime
    "Greater than the specified value."
    greaterThan: Datetime
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: Datetime
    "Included in the specified list."
    in: [Datetime!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: Datetime
    "Less than or equal to the specified value."
    lessThanOrEqualTo: Datetime
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: Datetime
    "Not equal to the specified value."
    notEqualTo: Datetime
    "Not included in the specified list."
    notIn: [Datetime!]
}

"All input for the `deleteClsBotByUuid` mutation."
input DeleteClsBotByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    uuid: UUID!
}

"All input for the `deleteClsBot` mutation."
input DeleteClsBotInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `ClsBot` to be deleted."
    nodeId: ID!
}

"All input for the `deleteClsEventTypeByUuid` mutation."
input DeleteClsEventTypeByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    uuid: UUID!
}

"All input for the `deleteClsEventType` mutation."
input DeleteClsEventTypeInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `ClsEventType` to be deleted."
    nodeId: ID!
}

"All input for the `deleteClsMessengerByUuid` mutation."
input DeleteClsMessengerByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    uuid: UUID!
}

"All input for the `deleteClsMessenger` mutation."
input DeleteClsMessengerInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `ClsMessenger` to be deleted."
    nodeId: ID!
}

"All input for the `deleteClsTargetSystemByUuid` mutation."
input DeleteClsTargetSystemByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    uuid: UUID!
}

"All input for the `deleteClsTargetSystem` mutation."
input DeleteClsTargetSystemInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `ClsTargetSystem` to be deleted."
    nodeId: ID!
}

"All input for the `deleteClsUserByUuid` mutation."
input DeleteClsUserByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    uuid: UUID!
}

"All input for the `deleteClsUser` mutation."
input DeleteClsUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `ClsUser` to be deleted."
    nodeId: ID!
}

"All input for the `deleteNoSentMessages` mutation."
input DeleteNoSentMessagesInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    threshold: Int!
}

"All input for the `deleteNoSentRequests` mutation."
input DeleteNoSentRequestsInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    threshold: Int!
}

"All input for the `deleteReadRequests` mutation."
input DeleteReadRequestsInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    threshold: Int!
}

"All input for the `deleteRegIncomRequestByUuid` mutation."
input DeleteRegIncomRequestByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    uuid: UUID!
}

"All input for the `deleteRegIncomRequest` mutation."
input DeleteRegIncomRequestInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `RegIncomRequest` to be deleted."
    nodeId: ID!
}

"All input for the `deleteRegMessageRouteByUuid` mutation."
input DeleteRegMessageRouteByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    uuid: UUID!
}

"All input for the `deleteRegMessageRoute` mutation."
input DeleteRegMessageRouteInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `RegMessageRoute` to be deleted."
    nodeId: ID!
}

"All input for the `deleteRegMessengerUserByUuid` mutation."
input DeleteRegMessengerUserByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    uuid: UUID!
}

"All input for the `deleteRegMessengerUser` mutation."
input DeleteRegMessengerUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `RegMessengerUser` to be deleted."
    nodeId: ID!
}

"All input for the `deleteRegSentMessageByUuid` mutation."
input DeleteRegSentMessageByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    uuid: UUID!
}

"All input for the `deleteRegSentMessage` mutation."
input DeleteRegSentMessageInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `RegSentMessage` to be deleted."
    nodeId: ID!
}

"All input for the `deleteRegTargetSystemUserByUuid` mutation."
input DeleteRegTargetSystemUserByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    uuid: UUID!
}

"All input for the `deleteRegTargetSystemUser` mutation."
input DeleteRegTargetSystemUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `RegTargetSystemUser` to be deleted."
    nodeId: ID!
}

"All input for the `deleteSentMessages` mutation."
input DeleteSentMessagesInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    threshold: Int!
}

"All input for the `deleteSentRequests` mutation."
input DeleteSentRequestsInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    threshold: Int!
}

"A filter to be used against Int fields. All fields are combined with a logical ‘and.’"
input IntFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: Int
    "Equal to the specified value."
    equalTo: Int
    "Greater than the specified value."
    greaterThan: Int
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: Int
    "Included in the specified list."
    in: [Int!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: Int
    "Less than or equal to the specified value."
    lessThanOrEqualTo: Int
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: Int
    "Not equal to the specified value."
    notEqualTo: Int
    "Not included in the specified list."
    notIn: [Int!]
}

"A filter to be used against JSON fields. All fields are combined with a logical ‘and.’"
input JSONFilter {
    "Contained by the specified JSON."
    containedBy: JSON
    "Contains the specified JSON."
    contains: JSON
    "Contains all of the specified keys."
    containsAllKeys: [String!]
    "Contains any of the specified keys."
    containsAnyKeys: [String!]
    "Contains the specified key."
    containsKey: String
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: JSON
    "Equal to the specified value."
    equalTo: JSON
    "Greater than the specified value."
    greaterThan: JSON
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: JSON
    "Included in the specified list."
    in: [JSON!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: JSON
    "Less than or equal to the specified value."
    lessThanOrEqualTo: JSON
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: JSON
    "Not equal to the specified value."
    notEqualTo: JSON
    "Not included in the specified list."
    notIn: [JSON!]
}

"A condition to be used against `RegIncomRequest` object types. All fields are tested for equality and combined with a logical ‘and.’"
input RegIncomRequestCondition {
    "Checks for equality with the object’s `dateCreate` field."
    dateCreate: Datetime
    "Checks for equality with the object’s `idBot` field."
    idBot: UUID
    "Checks for equality with the object’s `idEventType` field."
    idEventType: UUID
    "Checks for equality with the object’s `idMessenger` field."
    idMessenger: UUID
    "Checks for equality with the object’s `idTargetSystem` field."
    idTargetSystem: UUID
    "Checks for equality with the object’s `idUser` field."
    idUser: UUID
    "Checks for equality with the object’s `status` field."
    status: Int
    "Checks for equality with the object’s `uuid` field."
    uuid: UUID
}

"A filter to be used against `RegIncomRequest` object types. All fields are combined with a logical ‘and.’"
input RegIncomRequestFilter {
    "Checks for all expressions in this list."
    and: [RegIncomRequestFilter!]
    "Filter by the object’s `dateCreate` field."
    dateCreate: DatetimeFilter
    "Filter by the object’s `idBot` field."
    idBot: UUIDFilter
    "Filter by the object’s `idEventType` field."
    idEventType: UUIDFilter
    "Filter by the object’s `idMessenger` field."
    idMessenger: UUIDFilter
    "Filter by the object’s `idTargetSystem` field."
    idTargetSystem: UUIDFilter
    "Filter by the object’s `idUser` field."
    idUser: UUIDFilter
    "Negates the expression."
    not: RegIncomRequestFilter
    "Checks for any expressions in this list."
    or: [RegIncomRequestFilter!]
    "Filter by the object’s `status` field."
    status: IntFilter
    "Filter by the object’s `uuid` field."
    uuid: UUIDFilter
}

"An input for mutations affecting `RegIncomRequest`"
input RegIncomRequestInput {
    dateCreate: Datetime
    idBot: UUID!
    idEventType: UUID!
    idMessenger: UUID!
    idTargetSystem: UUID!
    idUser: UUID
    status: Int
    uuid: UUID
}

"Represents an update to a `RegIncomRequest`. Fields that are set will be updated."
input RegIncomRequestPatch {
    dateCreate: Datetime
    idBot: UUID
    idEventType: UUID
    idMessenger: UUID
    idTargetSystem: UUID
    idUser: UUID
    status: Int
    uuid: UUID
}

"A condition to be used against `RegMessageRoute` object types. All fields are tested for equality and combined with a logical ‘and.’"
input RegMessageRouteCondition {
    "Checks for equality with the object’s `dateActivation` field."
    dateActivation: Datetime
    "Checks for equality with the object’s `dateCreate` field."
    dateCreate: Datetime
    "Checks for equality with the object’s `idBot` field."
    idBot: UUID
    "Checks for equality with the object’s `idEventType` field."
    idEventType: UUID
    "Checks for equality with the object’s `idMessenger` field."
    idMessenger: UUID
    "Checks for equality with the object’s `idTargetSystem` field."
    idTargetSystem: UUID
    "Checks for equality with the object’s `idUser` field."
    idUser: UUID
    "Checks for equality with the object’s `isDeleted` field."
    isDeleted: Boolean
    "Checks for equality with the object’s `uuid` field."
    uuid: UUID
}

"A filter to be used against `RegMessageRoute` object types. All fields are combined with a logical ‘and.’"
input RegMessageRouteFilter {
    "Checks for all expressions in this list."
    and: [RegMessageRouteFilter!]
    "Filter by the object’s `dateActivation` field."
    dateActivation: DatetimeFilter
    "Filter by the object’s `dateCreate` field."
    dateCreate: DatetimeFilter
    "Filter by the object’s `idBot` field."
    idBot: UUIDFilter
    "Filter by the object’s `idEventType` field."
    idEventType: UUIDFilter
    "Filter by the object’s `idMessenger` field."
    idMessenger: UUIDFilter
    "Filter by the object’s `idTargetSystem` field."
    idTargetSystem: UUIDFilter
    "Filter by the object’s `idUser` field."
    idUser: UUIDFilter
    "Filter by the object’s `isDeleted` field."
    isDeleted: BooleanFilter
    "Negates the expression."
    not: RegMessageRouteFilter
    "Checks for any expressions in this list."
    or: [RegMessageRouteFilter!]
    "Filter by the object’s `uuid` field."
    uuid: UUIDFilter
}

"An input for mutations affecting `RegMessageRoute`"
input RegMessageRouteInput {
    dateActivation: Datetime
    dateCreate: Datetime
    idBot: UUID!
    idEventType: UUID!
    idMessenger: UUID!
    idTargetSystem: UUID!
    idUser: UUID
    isDeleted: Boolean
    uuid: UUID
}

"Represents an update to a `RegMessageRoute`. Fields that are set will be updated."
input RegMessageRoutePatch {
    dateActivation: Datetime
    dateCreate: Datetime
    idBot: UUID
    idEventType: UUID
    idMessenger: UUID
    idTargetSystem: UUID
    idUser: UUID
    isDeleted: Boolean
    uuid: UUID
}

"A condition to be used against `RegMessengerUser` object types. All fields are tested for equality and combined with a logical ‘and.’"
input RegMessengerUserCondition {
    "Checks for equality with the object’s `dateCreate` field."
    dateCreate: Datetime
    "Checks for equality with the object’s `idMessenger` field."
    idMessenger: UUID
    "Checks for equality with the object’s `idUser` field."
    idUser: UUID
    "Checks for equality with the object’s `isDeleted` field."
    isDeleted: Boolean
    "Checks for equality with the object’s `outerId` field."
    outerId: String
    "Checks for equality with the object’s `settings` field."
    settings: JSON
    "Checks for equality with the object’s `uuid` field."
    uuid: UUID
}

"A filter to be used against `RegMessengerUser` object types. All fields are combined with a logical ‘and.’"
input RegMessengerUserFilter {
    "Checks for all expressions in this list."
    and: [RegMessengerUserFilter!]
    "Filter by the object’s `dateCreate` field."
    dateCreate: DatetimeFilter
    "Filter by the object’s `idMessenger` field."
    idMessenger: UUIDFilter
    "Filter by the object’s `idUser` field."
    idUser: UUIDFilter
    "Filter by the object’s `isDeleted` field."
    isDeleted: BooleanFilter
    "Negates the expression."
    not: RegMessengerUserFilter
    "Checks for any expressions in this list."
    or: [RegMessengerUserFilter!]
    "Filter by the object’s `outerId` field."
    outerId: StringFilter
    "Filter by the object’s `settings` field."
    settings: JSONFilter
    "Filter by the object’s `uuid` field."
    uuid: UUIDFilter
}

"An input for mutations affecting `RegMessengerUser`"
input RegMessengerUserInput {
    dateCreate: Datetime
    idMessenger: UUID!
    idUser: UUID
    isDeleted: Boolean
    outerId: String
    settings: JSON
    uuid: UUID
}

"Represents an update to a `RegMessengerUser`. Fields that are set will be updated."
input RegMessengerUserPatch {
    dateCreate: Datetime
    idMessenger: UUID
    idUser: UUID
    isDeleted: Boolean
    outerId: String
    settings: JSON
    uuid: UUID
}

"A condition to be used against `RegSentMessage` object types. All fields are tested for equality and combined with a logical ‘and.’"
input RegSentMessageCondition {
    "Checks for equality with the object’s `attachedFile` field."
    attachedFile: String
    "Checks for equality with the object’s `attachedFileHash` field."
    attachedFileHash: String
    "Checks for equality with the object’s `attachedFileSize` field."
    attachedFileSize: Int
    "Checks for equality with the object’s `attachedFileType` field."
    attachedFileType: String
    "Checks for equality with the object’s `dateCreate` field."
    dateCreate: Datetime
    "Checks for equality with the object’s `idEventType` field."
    idEventType: UUID
    "Checks for equality with the object’s `idIncomRequest` field."
    idIncomRequest: UUID
    "Checks for equality with the object’s `idTargetSystem` field."
    idTargetSystem: UUID
    "Checks for equality with the object’s `idUser` field."
    idUser: UUID
    "Checks for equality with the object’s `settings` field."
    settings: JSON
    "Checks for equality with the object’s `status` field."
    status: Int
    "Checks for equality with the object’s `text` field."
    text: String
    "Checks for equality with the object’s `uuid` field."
    uuid: UUID
}

"A filter to be used against `RegSentMessage` object types. All fields are combined with a logical ‘and.’"
input RegSentMessageFilter {
    "Checks for all expressions in this list."
    and: [RegSentMessageFilter!]
    "Filter by the object’s `attachedFile` field."
    attachedFile: StringFilter
    "Filter by the object’s `attachedFileHash` field."
    attachedFileHash: StringFilter
    "Filter by the object’s `attachedFileSize` field."
    attachedFileSize: IntFilter
    "Filter by the object’s `attachedFileType` field."
    attachedFileType: StringFilter
    "Filter by the object’s `dateCreate` field."
    dateCreate: DatetimeFilter
    "Filter by the object’s `idEventType` field."
    idEventType: UUIDFilter
    "Filter by the object’s `idIncomRequest` field."
    idIncomRequest: UUIDFilter
    "Filter by the object’s `idTargetSystem` field."
    idTargetSystem: UUIDFilter
    "Filter by the object’s `idUser` field."
    idUser: UUIDFilter
    "Negates the expression."
    not: RegSentMessageFilter
    "Checks for any expressions in this list."
    or: [RegSentMessageFilter!]
    "Filter by the object’s `settings` field."
    settings: JSONFilter
    "Filter by the object’s `status` field."
    status: IntFilter
    "Filter by the object’s `text` field."
    text: StringFilter
    "Filter by the object’s `uuid` field."
    uuid: UUIDFilter
}

"An input for mutations affecting `RegSentMessage`"
input RegSentMessageInput {
    attachedFile: String
    attachedFileHash: String
    attachedFileSize: Int
    attachedFileType: String
    dateCreate: Datetime
    idEventType: UUID!
    idIncomRequest: UUID
    idTargetSystem: UUID!
    idUser: UUID
    settings: JSON
    status: Int
    text: String
    uuid: UUID
}

"Represents an update to a `RegSentMessage`. Fields that are set will be updated."
input RegSentMessagePatch {
    attachedFile: String
    attachedFileHash: String
    attachedFileSize: Int
    attachedFileType: String
    dateCreate: Datetime
    idEventType: UUID
    idIncomRequest: UUID
    idTargetSystem: UUID
    idUser: UUID
    settings: JSON
    status: Int
    text: String
    uuid: UUID
}

"A condition to be used against `RegTargetSystemUser` object types. All fields are tested for equality and combined with a logical ‘and.’"
input RegTargetSystemUserCondition {
    "Checks for equality with the object’s `dateCreate` field."
    dateCreate: Datetime
    "Checks for equality with the object’s `email` field."
    email: String
    "Checks for equality with the object’s `firstname` field."
    firstname: String
    "Checks for equality with the object’s `idTargetSystem` field."
    idTargetSystem: UUID
    "Checks for equality with the object’s `idUser` field."
    idUser: UUID
    "Checks for equality with the object’s `isDeleted` field."
    isDeleted: Boolean
    "Checks for equality with the object’s `lastname` field."
    lastname: String
    "Checks for equality with the object’s `login` field."
    login: String
    "Checks for equality with the object’s `outerId` field."
    outerId: String
    "Checks for equality with the object’s `patronymic` field."
    patronymic: String
    "Checks for equality with the object’s `uuid` field."
    uuid: UUID
}

"A filter to be used against `RegTargetSystemUser` object types. All fields are combined with a logical ‘and.’"
input RegTargetSystemUserFilter {
    "Checks for all expressions in this list."
    and: [RegTargetSystemUserFilter!]
    "Filter by the object’s `dateCreate` field."
    dateCreate: DatetimeFilter
    "Filter by the object’s `email` field."
    email: StringFilter
    "Filter by the object’s `firstname` field."
    firstname: StringFilter
    "Filter by the object’s `idTargetSystem` field."
    idTargetSystem: UUIDFilter
    "Filter by the object’s `idUser` field."
    idUser: UUIDFilter
    "Filter by the object’s `isDeleted` field."
    isDeleted: BooleanFilter
    "Filter by the object’s `lastname` field."
    lastname: StringFilter
    "Filter by the object’s `login` field."
    login: StringFilter
    "Negates the expression."
    not: RegTargetSystemUserFilter
    "Checks for any expressions in this list."
    or: [RegTargetSystemUserFilter!]
    "Filter by the object’s `outerId` field."
    outerId: StringFilter
    "Filter by the object’s `patronymic` field."
    patronymic: StringFilter
    "Filter by the object’s `uuid` field."
    uuid: UUIDFilter
}

"An input for mutations affecting `RegTargetSystemUser`"
input RegTargetSystemUserInput {
    dateCreate: Datetime
    email: String
    firstname: String
    idTargetSystem: UUID!
    idUser: UUID
    isDeleted: Boolean
    lastname: String
    login: String
    outerId: String
    patronymic: String
    uuid: UUID
}

"Represents an update to a `RegTargetSystemUser`. Fields that are set will be updated."
input RegTargetSystemUserPatch {
    dateCreate: Datetime
    email: String
    firstname: String
    idTargetSystem: UUID
    idUser: UUID
    isDeleted: Boolean
    lastname: String
    login: String
    outerId: String
    patronymic: String
    uuid: UUID
}

"A filter to be used against String fields. All fields are combined with a logical ‘and.’"
input StringFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: String
    "Not equal to the specified value, treating null like an ordinary value (case-insensitive)."
    distinctFromInsensitive: String
    "Ends with the specified string (case-sensitive)."
    endsWith: String
    "Ends with the specified string (case-insensitive)."
    endsWithInsensitive: String
    "Equal to the specified value."
    equalTo: String
    "Equal to the specified value (case-insensitive)."
    equalToInsensitive: String
    "Greater than the specified value."
    greaterThan: String
    "Greater than the specified value (case-insensitive)."
    greaterThanInsensitive: String
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: String
    "Greater than or equal to the specified value (case-insensitive)."
    greaterThanOrEqualToInsensitive: String
    "Included in the specified list."
    in: [String!]
    "Included in the specified list (case-insensitive)."
    inInsensitive: [String!]
    "Contains the specified string (case-sensitive)."
    includes: String
    "Contains the specified string (case-insensitive)."
    includesInsensitive: String
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: String
    "Less than the specified value (case-insensitive)."
    lessThanInsensitive: String
    "Less than or equal to the specified value."
    lessThanOrEqualTo: String
    "Less than or equal to the specified value (case-insensitive)."
    lessThanOrEqualToInsensitive: String
    "Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
    like: String
    "Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
    likeInsensitive: String
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: String
    "Equal to the specified value, treating null like an ordinary value (case-insensitive)."
    notDistinctFromInsensitive: String
    "Does not end with the specified string (case-sensitive)."
    notEndsWith: String
    "Does not end with the specified string (case-insensitive)."
    notEndsWithInsensitive: String
    "Not equal to the specified value."
    notEqualTo: String
    "Not equal to the specified value (case-insensitive)."
    notEqualToInsensitive: String
    "Not included in the specified list."
    notIn: [String!]
    "Not included in the specified list (case-insensitive)."
    notInInsensitive: [String!]
    "Does not contain the specified string (case-sensitive)."
    notIncludes: String
    "Does not contain the specified string (case-insensitive)."
    notIncludesInsensitive: String
    "Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
    notLike: String
    "Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
    notLikeInsensitive: String
    "Does not start with the specified string (case-sensitive)."
    notStartsWith: String
    "Does not start with the specified string (case-insensitive)."
    notStartsWithInsensitive: String
    "Starts with the specified string (case-sensitive)."
    startsWith: String
    "Starts with the specified string (case-insensitive)."
    startsWithInsensitive: String
}

"A filter to be used against UUID fields. All fields are combined with a logical ‘and.’"
input UUIDFilter {
    "Not equal to the specified value, treating null like an ordinary value."
    distinctFrom: UUID
    "Equal to the specified value."
    equalTo: UUID
    "Greater than the specified value."
    greaterThan: UUID
    "Greater than or equal to the specified value."
    greaterThanOrEqualTo: UUID
    "Included in the specified list."
    in: [UUID!]
    "Is null (if `true` is specified) or is not null (if `false` is specified)."
    isNull: Boolean
    "Less than the specified value."
    lessThan: UUID
    "Less than or equal to the specified value."
    lessThanOrEqualTo: UUID
    "Equal to the specified value, treating null like an ordinary value."
    notDistinctFrom: UUID
    "Not equal to the specified value."
    notEqualTo: UUID
    "Not included in the specified list."
    notIn: [UUID!]
}

"All input for the `updateClsBotByUuid` mutation."
input UpdateClsBotByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `ClsBot` being updated."
    clsBotPatch: ClsBotPatch!
    uuid: UUID!
}

"All input for the `updateClsBot` mutation."
input UpdateClsBotInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `ClsBot` being updated."
    clsBotPatch: ClsBotPatch!
    "The globally unique `ID` which will identify a single `ClsBot` to be updated."
    nodeId: ID!
}

"All input for the `updateClsEventTypeByUuid` mutation."
input UpdateClsEventTypeByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `ClsEventType` being updated."
    clsEventTypePatch: ClsEventTypePatch!
    uuid: UUID!
}

"All input for the `updateClsEventType` mutation."
input UpdateClsEventTypeInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `ClsEventType` being updated."
    clsEventTypePatch: ClsEventTypePatch!
    "The globally unique `ID` which will identify a single `ClsEventType` to be updated."
    nodeId: ID!
}

"All input for the `updateClsMessengerByUuid` mutation."
input UpdateClsMessengerByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `ClsMessenger` being updated."
    clsMessengerPatch: ClsMessengerPatch!
    uuid: UUID!
}

"All input for the `updateClsMessenger` mutation."
input UpdateClsMessengerInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `ClsMessenger` being updated."
    clsMessengerPatch: ClsMessengerPatch!
    "The globally unique `ID` which will identify a single `ClsMessenger` to be updated."
    nodeId: ID!
}

"All input for the `updateClsTargetSystemByUuid` mutation."
input UpdateClsTargetSystemByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `ClsTargetSystem` being updated."
    clsTargetSystemPatch: ClsTargetSystemPatch!
    uuid: UUID!
}

"All input for the `updateClsTargetSystem` mutation."
input UpdateClsTargetSystemInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `ClsTargetSystem` being updated."
    clsTargetSystemPatch: ClsTargetSystemPatch!
    "The globally unique `ID` which will identify a single `ClsTargetSystem` to be updated."
    nodeId: ID!
}

"All input for the `updateClsUserByUuid` mutation."
input UpdateClsUserByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `ClsUser` being updated."
    clsUserPatch: ClsUserPatch!
    uuid: UUID!
}

"All input for the `updateClsUser` mutation."
input UpdateClsUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `ClsUser` being updated."
    clsUserPatch: ClsUserPatch!
    "The globally unique `ID` which will identify a single `ClsUser` to be updated."
    nodeId: ID!
}

"All input for the `updateRegIncomRequestByUuid` mutation."
input UpdateRegIncomRequestByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `RegIncomRequest` being updated."
    regIncomRequestPatch: RegIncomRequestPatch!
    uuid: UUID!
}

"All input for the `updateRegIncomRequest` mutation."
input UpdateRegIncomRequestInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `RegIncomRequest` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `RegIncomRequest` being updated."
    regIncomRequestPatch: RegIncomRequestPatch!
}

"All input for the `updateRegMessageRouteByUuid` mutation."
input UpdateRegMessageRouteByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `RegMessageRoute` being updated."
    regMessageRoutePatch: RegMessageRoutePatch!
    uuid: UUID!
}

"All input for the `updateRegMessageRoute` mutation."
input UpdateRegMessageRouteInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `RegMessageRoute` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `RegMessageRoute` being updated."
    regMessageRoutePatch: RegMessageRoutePatch!
}

"All input for the `updateRegMessengerUserByUuid` mutation."
input UpdateRegMessengerUserByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `RegMessengerUser` being updated."
    regMessengerUserPatch: RegMessengerUserPatch!
    uuid: UUID!
}

"All input for the `updateRegMessengerUser` mutation."
input UpdateRegMessengerUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `RegMessengerUser` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `RegMessengerUser` being updated."
    regMessengerUserPatch: RegMessengerUserPatch!
}

"All input for the `updateRegSentMessageByUuid` mutation."
input UpdateRegSentMessageByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `RegSentMessage` being updated."
    regSentMessagePatch: RegSentMessagePatch!
    uuid: UUID!
}

"All input for the `updateRegSentMessage` mutation."
input UpdateRegSentMessageInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `RegSentMessage` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `RegSentMessage` being updated."
    regSentMessagePatch: RegSentMessagePatch!
}

"All input for the `updateRegTargetSystemUserByUuid` mutation."
input UpdateRegTargetSystemUserByUuidInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "An object where the defined keys will be set on the `RegTargetSystemUser` being updated."
    regTargetSystemUserPatch: RegTargetSystemUserPatch!
    uuid: UUID!
}

"All input for the `updateRegTargetSystemUser` mutation."
input UpdateRegTargetSystemUserInput {
    "An arbitrary string value with no semantic meaning. Will be included in the payload verbatim. May be used to track mutations by the client."
    clientMutationId: String
    "The globally unique `ID` which will identify a single `RegTargetSystemUser` to be updated."
    nodeId: ID!
    "An object where the defined keys will be set on the `RegTargetSystemUser` being updated."
    regTargetSystemUserPatch: RegTargetSystemUserPatch!
}

"A condition to be used against `VMessengerUserMessageRoute` object types. All fields are tested for equality and combined with a logical ‘and.’"
input VMessengerUserMessageRouteCondition {
    "Checks for equality with the object’s `botName` field."
    botName: String
    "Checks for equality with the object’s `botSettings` field."
    botSettings: JSON
    "Checks for equality with the object’s `idBot` field."
    idBot: UUID
    "Checks for equality with the object’s `idEventType` field."
    idEventType: UUID
    "Checks for equality with the object’s `idMessenger` field."
    idMessenger: UUID
    "Checks for equality with the object’s `idParentEventType` field."
    idParentEventType: UUID
    "Checks for equality with the object’s `idTargetSystem` field."
    idTargetSystem: UUID
    "Checks for equality with the object’s `idUser` field."
    idUser: UUID
    "Checks for equality with the object’s `messengerCode` field."
    messengerCode: String
    "Checks for equality with the object’s `outerId` field."
    outerId: String
    "Checks for equality with the object’s `typeEvent` field."
    typeEvent: Int
    "Checks for equality with the object’s `userSettings` field."
    userSettings: JSON
}

"A filter to be used against `VMessengerUserMessageRoute` object types. All fields are combined with a logical ‘and.’"
input VMessengerUserMessageRouteFilter {
    "Checks for all expressions in this list."
    and: [VMessengerUserMessageRouteFilter!]
    "Filter by the object’s `botName` field."
    botName: StringFilter
    "Filter by the object’s `botSettings` field."
    botSettings: JSONFilter
    "Filter by the object’s `idBot` field."
    idBot: UUIDFilter
    "Filter by the object’s `idEventType` field."
    idEventType: UUIDFilter
    "Filter by the object’s `idMessenger` field."
    idMessenger: UUIDFilter
    "Filter by the object’s `idParentEventType` field."
    idParentEventType: UUIDFilter
    "Filter by the object’s `idTargetSystem` field."
    idTargetSystem: UUIDFilter
    "Filter by the object’s `idUser` field."
    idUser: UUIDFilter
    "Filter by the object’s `messengerCode` field."
    messengerCode: StringFilter
    "Negates the expression."
    not: VMessengerUserMessageRouteFilter
    "Checks for any expressions in this list."
    or: [VMessengerUserMessageRouteFilter!]
    "Filter by the object’s `outerId` field."
    outerId: StringFilter
    "Filter by the object’s `typeEvent` field."
    typeEvent: IntFilter
    "Filter by the object’s `userSettings` field."
    userSettings: JSONFilter
}


"A location in a connection that can be used for resuming pagination."
scalar Cursor

"A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122)."
scalar UUID

"A point in time as described by the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone."
scalar Datetime

"A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON

"A signed eight-byte integer. The upper big integer values are greater than the max value for a JavaScript number. Therefore all big integers will be output as strings and not numbers."
scalar BigInt
